/**
    Grammar definition FAC by Lena Papailiou

    updates:
    - moved tokens to jlang.flex
    - restructured so optional spaces will not require 'empty token'

 */

// ==================       DEFINITION STRUCTURE       ================== //

//      1) grammar definition in bnf syntax
//      2) lexical definition in flex syntax


// ==================       SYNTACTICAL DEFINITIONS       ================== //
// start symbol for file scope. this is a one-file-language (classes not implemented)
<S> 	        ::= <FILE>

// file structure definition. a file must have a 'main call', with optional variable and function definitions. the order is given by the grammar
<FILE> 	        ::= <MAINCALL> <NWL_SPACE> <REP_FUNDEF>
                    | <REP_VARDEF> <NWL_SPACE> <MAINCALL>
                    | <REP_VARDEF> <NWL_SPACE> <MAINCALL> <NWL_SPACE> <REP_FUNDEF>

// main call. at runtime, code within the main function should be executed java-like
<MAINCALL> 	    ::= <MAIN> <BL> <BR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <MAIN> <BL> <BR> <SPACE> <CBL> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <MAIN> <BL> <BR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR>
                    | <MAIN> <BL> <BR> <SPACE> <CBL>  <REP_STRUCT> <CBR>
                    | <MAIN> <BL> <BR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <MAIN> <BL> <BR> <CBL> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <MAIN> <BL> <BR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR>
                    | <MAIN> <BL> <BR> <CBL> <REP_STRUCT> <CBR>

// variable definitions
<REP_VARDEF> 	::= <VARDEF>
                    | <VARDEF> <REP_VARDEF>
<VARDEF> 	    ::= <BOOLVARDEF>
                    | <NUMVARDEF>
                    | <STRVARDEF>
<STRVARDEF> 	::= <STRTYPE> <SPACE> <STR> <SPACE> <EQUAL> <SPACE> <W> <STOP>
<NUMVARDEF> 	::= <NUMTYPE> <SPACE> <STR> <SPACE> <EQUAL> <SPACE> <N> <STOP>
<BOOLVARDEF> 	::= <BOOLTYPE> <SPACE> <STR> <SPACE> <EQUAL> <SPACE> <BOOL> <STOP>

// variable assignments
<ASSIGN> 	    ::= <STR> <SPACE> <ASSGN_N> <SPACE> <CALC> <STOP>
                    | <STR> <SPACE> <ASSGN_N> <CALC> <STOP>
                    | <STR> <ASSGN_N> <SPACE> <CALC> <STOP>
                    | <STR> <ASSGN_N> <CALC> <STOP>
                    | <STR> <SPACE> <ASSGN_N> <SPACE> <N> <STOP>
                    | <STR> <SPACE> <ASSGN_N> <N> <STOP>
                    | <STR> <ASSGN_N> <SPACE> <N> <STOP>
                    | <STR> <ASSGN_N> <N> <STOP>
                    | <STR> <SPACE> <ASSGN_N> <SPACE> <STR> <STOP>
                    | <STR> <SPACE> <ASSGN_N> <STR> <STOP>
                    | <STR> <ASSGN_N> <SPACE> <STR> <STOP>
                    | <STR> <ASSGN_N> <STR> <STOP>
                    | <STR> <SPACE> <ASSGN_W> <SPACE> <CONCAT> <STOP>
                    | <STR> <SPACE> <ASSGN_W> <CONCAT> <STOP>
                    | <STR> <ASSGN_W> <SPACE> <CONCAT> <STOP>
                    | <STR>  <ASSGN_W> <CONCAT> <STOP>
                    | <STR> <SPACE> <ASSGN_W> <SPACE> <W> <STOP>
                    | <STR> <SPACE> <ASSGN_W> <W> <STOP>
                    | <STR> <ASSGN_W> <SPACE> <W> <STOP>
                    | <STR> <ASSGN_W> <W> <STOP>
                    | <STR> <SPACE> <EQUAL> <SPACE> <BOOL> <STOP>
                    | <STR> <SPACE> <EQUAL> <BOOL> <STOP>
                    | <STR> <EQUAL> <SPACE> <BOOL> <STOP>
                    | <STR> <EQUAL> <BOOL> <STOP>
                    | <STR> <SPACE> <EQUAL> <SPACE> <EXPR> <STOP>
                    | <STR> <SPACE> <EQUAL> <EXPR> <STOP>
                    | <STR> <EQUAL> <SPACE> <EXPR> <STOP>
                    | <STR> <EQUAL> <EXPR> <STOP>
                    | <STR> <SPACE> <EQUAL> <SPACE> <FUNCALL> <STOP>    // assign result of function
                    | <STR> <SPACE> <EQUAL> <FUNCALL> <STOP>
                    | <STR> <EQUAL> <SPACE> <FUNCALL> <STOP>
                    | <STR> <EQUAL> <FUNCALL> <STOP>

// string concatenation
<CONCAT> 	    ::= <W_STR> <SPACE> <PLUS> <SPACE> <CONCAT>
                    | <W_STR> <SPACE> <PLUS> <CONCAT>
                    | <W_STR> <PLUS> <SPACE> <CONCAT>
                    | <W_STR> <PLUS><CONCAT>
                    | <W_STR> <SPACE> <PLUS> <SPACE> <W_STR>
                    | <W_STR> <SPACE> <PLUS> <W_STR>
                    | <W_STR> <PLUS> <SPACE> <W_STR>
                    | <W_STR> <PLUS> <W_STR>

// arithmetic expressions. brackets are optional, mul/div has precedence over plus/minus
<CALC> 	        ::= <CALC_MUL>
                    | <BL> <CALC_MUL> <BR>
                    | <CALC> <SPACE> <PLUS_OPERATOR> <SPACE> <CALC_MUL>
                    | <CALC> <SPACE> <PLUS_OPERATOR> <CALC_MUL>
                    | <CALC> <PLUS_OPERATOR> <SPACE> <CALC_MUL>
                    | <CALC> <PLUS_OPERATOR> <CALC_MUL>
<CALC_MUL>      ::= <CALC_ELEMENT>
                    | <BL> <CALC_MUL> <BR>
                    | <CALC_MUL> <SPACE> <MUL_OPERATOR> <SPACE> <CALC_ELEMENT>
                    | <CALC_MUL> <SPACE> <MUL_OPERATOR> <CALC_ELEMENT>
                    | <CALC_MUL> <MUL_OPERATOR> <SPACE> <CALC_ELEMENT>
                    | <CALC_MUL> <MUL_OPERATOR> <CALC_ELEMENT>
<CALC_ELEMENT>  ::= <N_STR>
                    | <BL> <CALC> <BR>
                    | <BL> <CALC_ELEMENT> <BR>
<PLUS_OPERATOR> ::= <PLUS>
                    | <MINUS>
<MUL_OPERATOR>  ::= <MUL>
                    | <DIV>

// boolean expressions. brackets are mandatory, no precedence order needed
<EXPR> 	        ::= <BL> <BOOL_STR> <BR>
                    | <BL> <BOOL_STR> <SPACE> <EV> <SPACE> <BOOL_STR> <BR>
                    | <BL> <BOOL_STR> <SPACE> <EV> <BOOL_STR> <BR>
                    | <BL> <BOOL_STR> <EV> <SPACE> <BOOL_STR> <BR>
                    | <BL> <BOOL_STR> <EV> <BOOL_STR> <BR>
                    | <BL> <BOOL_STR> <SPACE> <EV> <SPACE> <EXPR> <BR>
                    | <BL> <BOOL_STR> <SPACE> <EV> <EXPR> <BR>
                    | <BL> <BOOL_STR> <EV> <SPACE> <EXPR> <BR>
                    | <BL> <BOOL_STR> <EV> <EXPR> <BR>
                    | <BL> <CALC> <SPACE> <COMP_N> <SPACE> <N_STR> <BR>
                    | <BL> <CALC> <SPACE> <COMP_N> <N_STR> <BR>
                    | <BL> <CALC> <COMP_N> <SPACE> <N_STR> <BR>
                    | <BL> <CALC> <COMP_N> <N_STR> <BR>
                    | <BL> <EXPR> <SPACE> <EV> <SPACE> <BOOL_STR> <BR>
                    | <BL> <EXPR> <SPACE> <EV> <BOOL_STR> <BR>
                    | <BL> <EXPR> <EV> <SPACE> <BOOL_STR> <BR>
                    | <BL> <EXPR> <EV> <BOOL_STR> <BR>
                    | <BL> <N_STR> <SPACE> <COMP_N> <SPACE> <CALC> <BR>
                    | <BL> <N_STR> <SPACE> <COMP_N> <CALC> <BR>
                    | <BL> <N_STR> <COMP_N> <SPACE> <CALC> <BR>
                    | <BL> <N_STR> <COMP_N> <CALC> <BR>
                    | <BL> <N_STR> <SPACE> <COMP_N> <SPACE> <N_STR> <BR>
                    | <BL> <N_STR> <SPACE> <COMP_N> <N_STR> <BR>
                    | <BL> <N_STR> <COMP_N> <SPACE> <N_STR> <BR>
                    | <BL> <N_STR> <COMP_N> <N_STR> <BR>
                    | <BL> <W_STR> <SPACE> <COMP> <SPACE> <W_STR> <BR>
                    | <BL> <W_STR> <SPACE> <COMP> <W_STR> <BR>
                    | <BL> <W_STR> <COMP> <SPACE> <W_STR> <BR>
                    | <BL> <W_STR> <COMP> <W_STR> <BR>

// function definitions. a function must have parameters and must return a string, number or boolean
<REP_PARAMDEF> 	::= <PARAMDEF>
                    | <PARAMDEF> <COMMA> <SPACE> <REP_PARAMDEF>
                    | <PARAMDEF> <COMMA> <REP_PARAMDEF>
<PARAMDEF> 	    ::= <TYPEWORD> <SPACE> <STR>
<REP_FUNDEF> 	::= <FUNDEF>
                    | <FUNDEF> <REP_FUNDEF>
<FUNDEF> 	    ::= <DEF> <SPACE> <TYPEWORD> <SPACE> <STR> <BL> <REP_PARAMDEF> <BR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <RET> <CBR> <NWL_SPACE>
                    | <DEF> <SPACE> <TYPEWORD> <SPACE> <STR> <BL> <REP_PARAMDEF> <BR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <RET> <CBR>
                    | <DEF> <SPACE> <TYPEWORD> <SPACE> <STR> <BL> <REP_PARAMDEF> <BR> <SPACE> <CBL> <REP_STRUCT> <RET> <CBR> <NWL_SPACE>
                    | <DEF> <SPACE> <TYPEWORD> <SPACE> <STR> <BL> <REP_PARAMDEF> <BR> <SPACE> <CBL> <REP_STRUCT> <RET> <CBR>
<PARAM> 	    ::= <TYPE>
                    | <TYPE> <COMMA> <SPACE> <PARAM>
<FUNCALL> 	    ::= <STR> <BL> <PARAM> <BR>

// this function should print the content of the variable to the console when called
<PRINTCALL> 	::= <PRINT> <BL> <TYPE> <BR> <STOP>

// structures (variable definitions and assignments, if-else, while, ...)
<REP_STRUCT> 	::= <STRUCT>
                    | <STRUCT> <REP_STRUCT>
<STRUCT> 	    ::= <ASSIGN>
                    | <PRINTCALL>
                    | <VARDEF>
                    | <IF> <SPACE> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <SPACE> <ELSE> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <SPACE> <ELSE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <ELSE> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <ELSE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <SPACE> <ELSE> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <SPACE> <ELSE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <ELSE> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <SPACE> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <ELSE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <SPACE> <ELSE> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <SPACE> <ELSE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <ELSE> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <ELSE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <SPACE> <ELSE> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <SPACE> <ELSE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <ELSE> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <IF> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <ELSE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <WHILE> <SPACE> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <WHILE> <SPACE> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <WHILE> <EXPR> <SPACE> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>
                    | <WHILE> <EXPR> <CBL> <NWL_SPACE> <REP_STRUCT> <CBR> <NWL_SPACE>

// --------------------- helper structures ---------------------

// assignment operators for numbers and strings
<ASSGN_N> 	    ::= <EQUAL>
                    | <PLUSEQ>
                    | <MINEQ>
                    | <DIVEQ>
                    | <MULEQ>
<ASSGN_W> 	    ::= <EQUAL>
                    | <PLUSEQ>
// comparators for strings/booleans and number comparisons
<COMP> 	        ::= <EQ>
                    | <NEQ>
<COMP_N> 	    ::= <COMP>
                    | <GREATER>
                    | <GREQ>
                    | <LEQ>
                    | <LESS>

// and / or / comparisons
<EV> 	        ::= <AND>
                    | <COMP>
                    | <OR>
// helper constructs
<RET> 	        ::= <RETURN> <SPACE> <TYPE> <STOP>

// the type words ('boolean', 'number', 'string')
<TYPEWORD> 	    ::= <BOOLTYPE>
                    | <NUMTYPE>
                    | <STRTYPE>

// boolean, number, string or variable
<TYPE> 	        ::= <BOOL>
                    | <N>
                    | <STR>
                    | <W>

// number or variable
<N_STR> 	    ::= <N>
                    | <STR>
// string or variable
<W_STR> 	    ::= <STR>
                    | <W>
// boolean or variable
<BOOL_STR> 	    ::= <BOOL>
                    | <STR>

<NWL_SPACE> 	::= <NL_SPACE>
                    | <SPACE>

