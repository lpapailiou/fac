package parser.parsetree;

import parser.parsetree.interfaces.Traversable;
import parser.parsetree.interfaces.Visitor;

import java.util.ArrayList;
import java.util.List;

/**
 * This is a wrapper class for the program instance. This is the root of the parse tree.
 * It will hold all first-level components of the program as statement list. Potentially,
 * every statement can have nested statements.
 */
public class Program implements Traversable {

    private final List<Component> componentList = new ArrayList<>();

    /**
     * This constructor initializes the wrapper for the root of the generated parse tree.
     * It contains the list of all top-level statements.
     *
     * @param componentList the list of all top-level statements.
     */
    public Program(List<Component> componentList) {
        this.componentList.addAll(componentList);
    }

    /**
     * Returns the list of top-level statements.
     *
     * @return the statement list.
     */
    public List<Component> getStatements() {
        return componentList;
    }

    /**
     * The toString method provides a pretty-printable String
     * of this parse tree component.
     * It is generated by the contents of this instance and may not be equal to the original code.
     *
     * @return the pretty-printed code.
     */
    @Override
    public String toString() {
        StringBuilder out = new StringBuilder();
        for (Component st : componentList) {
            out.append(st.toString());
        }

        return out.toString();
    }

    /**
     * This method returns the program components as a string of the parse tree.
     * The parse tree returned will not match the 'real' parse tree completely.
     * Some changes were made to make it more human-readable. Another reason is, that the classes generated
     * from the parse tree do not match the technical parse tree anymore.
     *
     * @return the complete parse tree represented as a string.
     */
    @Override
    public String getParseTree() {
        StringBuilder out = Component.getStringBuilder(this);
        if (componentList.size() > 0) {
            Component.appendLine(out, "StatementList", 1);
        }
        for (int i = 0; i < componentList.size(); i++) {
            Component comp = componentList.get(i);
            Component.appendLine(out, "ProgramStatement", 2);
            if (comp instanceof FunctionDefStatement) {
                Component.appendNestedComponents(out, comp, 3);
            } else {
                Component.appendLine(out, "Statement", 3);
                Component.appendNestedComponents(out, comp, 4);
            }
        }
        Component.appendLine(out, "EOF", 0);
        return out.toString();
    }

    /**
     * Returns the location from the source file of this code fragment.
     *
     * @return the location of this code fragment.
     */
    @Override
    public int[] getLocation() {
        return new int[]{0, 0};
    }

    /**
     * This method accepts a visitor. The visitor will then have access to this instance
     * for code validation and execution.
     *
     * @param visitor the visitor to accept.
     */
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

}
