package parser;
import parser.util.Declaration;
import parser.util.Program;
import scanner.JScanner;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;
/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
//
// java -jar java-cup-11b.jar -interface -destdir src/main/java/parser/ -symbols JSymbol -parser JParser src/main/java/parser/jparser.cup
parser code {:
:}

/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return getScanner().next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            RETURN, WHILE, IF, ELSE, DEF, PRINT,
                    BL, BR, CBL, CBR, COMMA, STOP,
                    EQUAL, LESS, GREATER, PLUS, MINUS, MUL, DIV, EQ, NEQ, GREQ, LEQ, AND, OR, PLUSEQ, MINEQ, MULEQ, DIVEQ;
terminal String     STR, STRTYPE, NUM, NUMTYPE, BOOL, BOOLTYPE, VAR;

/* Non terminals */
non terminal        ASSIGN, TYPE,
                    REP_PARAMDEF, TYPEDEF, REP_FUNDEF, FUNDEF, PARAM, FUNCALL, PRINTCALL, REP_STMT, STMT, DECL,
                    RET;

non terminal Program    program;
non terminal List<Object> stmtlist;
non terminal List<Declaration> decllist;
non terminal Boolean    COND, BOOL_VAL;
non terminal Double     EXPR, CALC_MUL, NUM_VAL;      // used to store evaluated subexpressions
non terminal String     CONCAT, STR_VAL;

/* Precedences */
precedence left PLUS, MINUS;
precedence left MUL, DIV;

/* The grammar rules */
start with program;
// --------------------- helper structures ---------------------
program         ::=  decllist:d stmtlist:s                                  {: RESULT = new Program(d, s); :}
                    ;

stmtlist        ::= stmtlist:sl STMT:s                                      {: sl.add(s); RESULT = sl; :}
                    | /* empty stmtlist */                                  {: RESULT = new LinkedList<Object>(); :}
                    ;
decllist        ::=  DECL:d decllist:dl                                     {: dl.add((Declaration)d); RESULT = dl; :}
                    | /* empty decllist */                                  {: RESULT = new ArrayList<Declaration>(); :}
                    ;

DECL 	    ::= STRTYPE:t VAR:e1 EQUAL STR:e2 STOP                      {: RESULT = new Declaration(t, e1, e2); :}
                    | NUMTYPE:t VAR:e1 EQUAL NUM:e2 STOP                {: RESULT = new Declaration(t, e1, e2); :}
                    | BOOLTYPE:t VAR:e1 EQUAL BOOL:e2 STOP                {: RESULT = new Declaration(t, e1, e2); :}
                    ;

TYPE            ::= STRTYPE:s                                                 {: RESULT = s; :}
                     | NUMTYPE:s                            {: RESULT = s; :}
                     | BOOLTYPE:s                                   {: RESULT = s; :}
                     ;

VAR             ::= VAR:v               {: RESULT = v; :}
;