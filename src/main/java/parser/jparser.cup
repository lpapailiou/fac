package parser;
import parser.parsetree.*;

import scanner.JScanner;
import java.util.List;

parser code {:
    public JParser(java.io.Reader in) {super(new JScanner(in));}
    public JParser(java.io.Reader in, boolean verbose) {super(new JScanner(in, verbose));}

    public boolean yyatEOF(){
        return ((JScanner) getScanner()).yyatEOF();
    }
:}

/* define how to connect to the scanner! */
scan with {: return getScanner().next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            WHILE, IF, ELSE, DEF, PRINT, BREAK, RETURN,
                    BL, BR, CBL, CBR, COMMA, STOP,
                    EQUAL, LESS, GREATER, PLUS, MINUS, MUL, DIV, EQ, NEQ, GREQ, LEQ, AND, OR, PLUSEQ, MINEQ, MULEQ, DIVEQ;
terminal String     STR, STRTYPE, NUM, NUMTYPE, BOOL, BOOLTYPE, VAR;

/* Non terminals */
non terminal        TYPE, PARAM, PARAMDEF, RET,
                    COND_OP, ASSIGN_OP, COND_VAL,
                    CALC_MUL,
                    VAL;

non terminal Program                    PROGRAM;
non terminal List<Statement>            STMT_LIST;
non terminal Statement                  STMT, PROG_STMT, NEST_STMT;
non terminal AssignmentStatement        ASSIGN;
non terminal ExpressionStatement        EXPR;
non terminal ConditionalExpression      COND;
non terminal FunctionCallStatement      FUNCALL;
non terminal FunctionDefStatement       FUNDEF;
non terminal PrintCallStatement         PRINTCALL;
non terminal IfThenStatement            IFTHEN_STMT;
non terminal WhileStatement             WHILE_STMT;
non terminal VariableDeclaration        DECL;


/* Precedences
precedence left PLUS, MINUS;        // TODO: is needed?
precedence left MUL, DIV;           // TODO: is needed?
*/

/* The grammar rules */
start with PROGRAM;

PROGRAM         ::= STMT_LIST:s                                                             {: RESULT = Statement.prog(s); :}
                    ;

STMT_LIST       ::= STMT_LIST:sl PROG_STMT:s                                                {: sl.add((Statement) s); RESULT = sl; :}
                    | /* empty STMT_LIST */                                                 {: RESULT = Statement.stmtList(); :}
                    ;

PROG_STMT       ::= STMT:st                                                                 {: RESULT = st; :}
                    | FUNDEF:st                                                             {: RESULT = st; :}
                    ;

NEST_STMT       ::= STMT:st                                                                 {: RESULT = Statement.nest(st); :}
                    | STMT:st NEST_STMT:stList                                              {: RESULT = Statement.nest(st, stList); :}
                    ;

STMT            ::= DECL:st                                                                 {: RESULT = st; :}
                    | ASSIGN:st                                                             {: RESULT = st; :}
                    | FUNCALL:st STOP                                                       {: RESULT = st; :}
                    | PRINTCALL:st                                                          {: RESULT = st; :}
                    | IFTHEN_STMT:st                                                        {: RESULT = st; :}
                    | WHILE_STMT:st                                                         {: RESULT = st; :}
                    | BREAK:br STOP                                                         {: RESULT = Statement.brk(); :}
                    ;

WHILE_STMT      ::= WHILE COND_VAL:c CBL NEST_STMT:s CBR                                    {: RESULT = Statement.loop(c, s); :}
                    | WHILE COND_VAL:c CBL CBR                                              {: RESULT = Statement.loop(c, null); :}
                    ;

IFTHEN_STMT     ::= IF COND_VAL:c CBL NEST_STMT:s CBR                                       {: RESULT = Statement.ifThen(c, s); :}
                    | IF COND_VAL:c CBL CBR                                                 {: RESULT = Statement.ifThen(c, null); :}
                    | IF COND_VAL:c CBL NEST_STMT:s1 CBR ELSE CBL NEST_STMT:s2 CBR          {: RESULT = Statement.ifThen(c, s1, s2); :}
                    | IF COND_VAL:c CBL CBR ELSE CBL NEST_STMT:s2 CBR                       {: RESULT = Statement.ifThen(c, null, s2); :}
                    | IF COND_VAL:c CBL NEST_STMT:s1 CBR ELSE CBL CBR                       {: RESULT = Statement.ifThen(c, s1, null); :}
                    | IF COND_VAL:c CBL CBR ELSE CBL CBR                                    {: RESULT = Statement.ifThen(c, null, null); :}
                    ;

COND_VAL        ::= COND:c                                                                  {: RESULT = c; :}
                    | BL VAR:c BR                                                           {: RESULT = c; :}
                    | BL BOOL:c BR                                                          {: RESULT = c; :}
                    ;

// function definition
FUNDEF 	        ::= DEF TYPE:t VAR:n BL PARAMDEF:p BR CBL NEST_STMT:st RET:r CBR            {: RESULT = Statement.funDef(t, n, p, st, r); :}
                    | DEF TYPE:t VAR:n BL PARAMDEF:p BR CBL RET:r CBR                       {: RESULT = Statement.funDefEmpty(t, n, p, r); :}
                    | DEF TYPE:t VAR:n BL BR CBL NEST_STMT:st RET:r CBR                     {: RESULT = Statement.funDef(t, n, st, r); :}
                    | DEF TYPE:t VAR:n BL BR CBL RET:r CBR                                  {: RESULT = Statement.funDefEmpty(t, n, r); :}
                    ;

PARAMDEF 	    ::= TYPE:t VAR:v                                                            {: RESULT = Statement.paramDecl(t, v); :}
                    | TYPE:t VAR:v COMMA PARAMDEF:p                                         {: RESULT = Statement.paramDecl(t, v, p); :}
                    ;

PARAM 	        ::= EXPR:t                                                                  {: RESULT = Statement.param(t); :}
                    | EXPR:t COMMA PARAM:p                                                  {: RESULT = Statement.param(t, p); :}
                    ;

RET 	        ::= RETURN EXPR:r STOP                                                      {: RESULT = r; :}
                    ;

// function calls
FUNCALL 	    ::= VAR:n BL PARAM:p BR                                                     {: RESULT = Statement.fun(n, p); :}
                    | VAR:n COND:p                                                          {: RESULT = Statement.fun(n, p); :}
                    | VAR:n BL BR                                                           {: RESULT = Statement.fun(n); :}
                    ;

PRINTCALL 	    ::= PRINT BL EXPR:v BR STOP                                                 {: RESULT = Statement.print(v); :}
                    | PRINT COND:v STOP                                                     {: RESULT = Statement.print(v); :}
                    | PRINT BL BR STOP                                                      {: RESULT = Statement.print(); :}
                    ;

// boolean conditions. brackets are mandatory, no precedence order needed
COND 	        ::= BL EXPR:e1 COND_OP:op EXPR:e2 BR                                        {: RESULT = Statement.cond(op, e1, e2); :}
                   ;

COND_OP         ::= AND:op                                                                  {: RESULT = op; :}
                    | OR:op                                                                 {: RESULT = op; :}
                    | EQ:op                                                                 {: RESULT = op; :}
                    | NEQ:op                                                                {: RESULT = op; :}
                    | GREATER:op                                                            {: RESULT = op; :}
                    | GREQ:op                                                               {: RESULT = op; :}
                    | LEQ:op                                                                {: RESULT = op; :}
                    | LESS:op                                                               {: RESULT = op; :}
                    ;

// arithmetic expressions. brackets are optional, mul/div has precedence over plus/minus
EXPR 	        ::=  CALC_MUL:e                                                             {: RESULT = Statement.expr(e); :}
                    | EXPR:e1 PLUS:op CALC_MUL:e2                                           {: RESULT = Statement.expr(op, e1, e2); :}
                    | EXPR:e1 MINUS:op CALC_MUL:e2                                          {: RESULT = Statement.expr(op, e1, e2); :}
                    ;

CALC_MUL        ::= VAL:e                                                                   {: RESULT = e; :}
                    | CALC_MUL:e1 MUL:op VAL:e2                                             {: RESULT = Statement.expr(op, e1, e2); :}
                    | CALC_MUL:e1 DIV:op VAL:e2                                             {: RESULT = Statement.expr(op, e1, e2); :}
                    ;

// variable assignments
ASSIGN 	        ::= VAR:e1 ASSIGN_OP:op EXPR:e2 STOP                                        {: RESULT = Statement.assgn(op, e1, e2); :}
                    ;

ASSIGN_OP       ::= EQUAL:op                                                                {: RESULT = op; :}
                    | PLUSEQ:op                                                             {: RESULT = op; :}
                    | MINEQ:op                                                              {: RESULT = op; :}
                    | DIVEQ:op                                                              {: RESULT = op; :}
                    | MULEQ:op                                                              {: RESULT = op; :}
                    ;

// variable declaration
DECL 	        ::= TYPE:t VAR:e1 STOP                                                      {: RESULT = Statement.decl(t, e1); :}
                    | TYPE:t VAR:e1 EQUAL EXPR:e2 STOP                                      {: RESULT = Statement.decl(t, e1, e2); :}
                    ;

// base components
TYPE            ::= STRTYPE:t                                                               {: RESULT = t; :}
                    | NUMTYPE:t                                                             {: RESULT = t; :}
                    | BOOLTYPE:t                                                            {: RESULT = t; :}
                    ;

VAL             ::= VAR:str                                                                 {: RESULT = str; :}
                    | STR:str                                                               {: RESULT = str; :}
                    | BOOL:b                                                                {: RESULT = b; :}
                    | NUM:n                                                                 {: RESULT = n; :}
                    | FUNCALL:f                                                             {: RESULT = f; :}
                    | COND:c                                                                {: RESULT = c; :}
                    ;

