package parser;
import parser.parsetree.*;

import scanner.JScanner;
import java.util.List;

// ************* CUSTOM PARSER CODE *************

parser code {:
    /**
     * Custom constructor which takes a reader. It will initialize a JScanner instance directly.
     * @param in the java.io.Reader.
     */
    public JParser(java.io.Reader in) {super(new JScanner(in));}

    /**
     * Custom constructor which takes a reader. It will initialize a JScanner instance directly.
     * @param in the java.io.Reader.
     * @param verbose a boolean to set the JScanner verbose attribute.
     */
    public JParser(java.io.Reader in, boolean verbose) {super(new JScanner(in, verbose));}

    /**
     * This method tests if the scanner reached the end of file yet.
     * @return true if the end of file is reached.
     */
    public boolean yyatEOF(){
        return ((JScanner) getScanner()).yyatEOF();
    }
:}

// definition of scanner connection
scan with {: return getScanner().next_token(); :};

// ************* TERMINAL AND NONTERMINAL DECLARATION & CONFIGURATION *************

// zerminals (tokens returned by the scanner)
terminal            WHILE, IF, ELSE, DEF, PRINT, BREAK, RETURN,
                    BL, BR, CBL, CBR, COMMA, STOP,
                    EQUAL, LESS, GREATER, PLUS, MINUS, MUL, DIV, EQ, NEQ, GREQ, LEQ, AND, OR, PLUSEQ, MINEQ, MULEQ, DIVEQ, MODEQ, MOD, EXCL, INC, DEC;
terminal String     STR, STRTYPE, NUM, NUMTYPE, BOOL, BOOLTYPE, VAR;

// non terminals
non terminal        TYPE, PARAM, PARAMDEF, RET,
                    COND_OP, ASSIGN_OP, COND_VAL,
                    CALC_MUL, VAL;

non terminal Program                    PROGRAM;
non terminal List<Component>            STMT_LIST;
non terminal Component                  STMT, PROG_STMT, NEST_STMT, EXPR;
non terminal AssignmentStatement        ASSIGN;
non terminal ConditionalExpression      COND;
non terminal FunctionCallStatement      FUNCALL;
non terminal FunctionDefStatement       FUNDEF;
non terminal PrintCallStatement         PRINTCALL;
non terminal IfThenStatement            IFTHEN_STMT;
non terminal WhileStatement             WHILE_STMT;
non terminal VariableDeclaration        DECL;

// precedences - not really required, but nice to have
precedence left PLUS, MINUS;
precedence left MOD, MUL, DIV;

// start symbol (root of parse tree)
start with PROGRAM;

// ************* SYNTACTICAL RULES *************

PROGRAM         ::= STMT_LIST:s                                                             {: RESULT = Component.prog(s); :}
                    ;

STMT_LIST       ::= STMT_LIST:sl PROG_STMT:s                                                {: sl.add((Component) s); RESULT = sl; :}
                    | /* empty STMT_LIST */                                                 {: RESULT = Component.stmtList(); :}
                    ;

PROG_STMT       ::= STMT:st                                                                 {: RESULT = st; :}
                    | FUNDEF:st                                                             {: RESULT = st; :}
                    ;

NEST_STMT       ::= STMT:st                                                                 {: RESULT = Component.nest(st); :}
                    | STMT:st NEST_STMT:stList                                              {: RESULT = Component.nest(st, stList); :}
                    ;

STMT            ::= DECL:st                                                                 {: RESULT = st; :}
                    | ASSIGN:st                                                             {: RESULT = st; :}
                    | FUNCALL:st STOP                                                       {: RESULT = st; :}
                    | PRINTCALL:st                                                          {: RESULT = st; :}
                    | IFTHEN_STMT:st                                                        {: RESULT = st; :}
                    | WHILE_STMT:st                                                         {: RESULT = st; :}
                    | BREAK:br STOP                                                         {: RESULT = Component.brk(); :}
                    ;

WHILE_STMT      ::= WHILE COND_VAL:c CBL NEST_STMT:s CBR                                    {: RESULT = Component.loop(c, s); :}
                    | WHILE COND_VAL:c CBL CBR                                              {: RESULT = Component.loop(c, null); :}
                    ;

IFTHEN_STMT     ::= IF COND_VAL:c CBL NEST_STMT:s CBR                                       {: RESULT = Component.ifThen(c, s); :}
                    | IF COND_VAL:c CBL CBR                                                 {: RESULT = Component.ifThen(c, null); :}
                    | IF COND_VAL:c CBL NEST_STMT:s1 CBR ELSE CBL NEST_STMT:s2 CBR          {: RESULT = Component.ifThen(c, s1, s2); :}
                    | IF COND_VAL:c CBL CBR ELSE CBL NEST_STMT:s2 CBR                       {: RESULT = Component.ifThen(c, null, s2); :}
                    | IF COND_VAL:c CBL NEST_STMT:s1 CBR ELSE CBL CBR                       {: RESULT = Component.ifThen(c, s1, null); :}
                    | IF COND_VAL:c CBL CBR ELSE CBL CBR                                    {: RESULT = Component.ifThen(c, null, null); :}
                    ;

COND_VAL        ::= COND:c                                                                  {: RESULT = c; :}
                    | BL VAL:c BR                                                           {: RESULT = c; :}
                    ;

// function definition
FUNDEF 	        ::= DEF TYPE:t VAR:n BL PARAMDEF:p BR CBL NEST_STMT:st RET:r CBR            {: RESULT = Component.funDef(t, n, p, st, r); :}
                    | DEF TYPE:t VAR:n BL PARAMDEF:p BR CBL RET:r CBR                       {: RESULT = Component.funDefEmpty(t, n, p, r); :}
                    | DEF TYPE:t VAR:n BL BR CBL NEST_STMT:st RET:r CBR                     {: RESULT = Component.funDef(t, n, st, r); :}
                    | DEF TYPE:t VAR:n BL BR CBL RET:r CBR                                  {: RESULT = Component.funDefEmpty(t, n, r); :}
                    ;

PARAMDEF 	    ::= TYPE:t VAR:v                                                            {: RESULT = Component.paramDecl(t, v); :}
                    | TYPE:t VAR:v COMMA PARAMDEF:p                                         {: RESULT = Component.paramDecl(t, v, p); :}
                    ;

PARAM 	        ::= EXPR:t                                                                  {: RESULT = Component.param(t); :}
                    | EXPR:t COMMA PARAM:p                                                  {: RESULT = Component.param(t, p); :}
                    ;

RET 	        ::= RETURN EXPR:r STOP                                                      {: RESULT = r; :}
                    ;

// function calls
FUNCALL 	    ::= VAR:n BL PARAM:p BR                                                     {: RESULT = Component.fun(n, p); :}
                    | VAR:n COND:p                                                          {: RESULT = Component.fun(n, p); :}
                    | VAR:n BL BR                                                           {: RESULT = Component.fun(n); :}
                    ;

PRINTCALL 	    ::= PRINT BL EXPR:v BR STOP                                                 {: RESULT = Component.print(v); :}
                    | PRINT COND:v STOP                                                     {: RESULT = Component.print(v); :}
                    | PRINT BL BR STOP                                                      {: RESULT = Component.print(); :}
                    ;

// boolean conditions. brackets are mandatory, no precedence order needed
COND 	        ::= BL EXPR:e1 COND_OP:op EXPR:e2 BR                                        {: RESULT = Component.cond(op, e1, e2); :}
                   ;

COND_OP         ::= AND:op                                                                  {: RESULT = op; :}
                    | OR:op                                                                 {: RESULT = op; :}
                    | EQ:op                                                                 {: RESULT = op; :}
                    | NEQ:op                                                                {: RESULT = op; :}
                    | GREATER:op                                                            {: RESULT = op; :}
                    | GREQ:op                                                               {: RESULT = op; :}
                    | LEQ:op                                                                {: RESULT = op; :}
                    | LESS:op                                                               {: RESULT = op; :}
                    ;

// arithmetic expressions. brackets are optional, mul/div has precedence over plus/minus
EXPR 	        ::=  CALC_MUL:e                                                             {: RESULT = Component.constnt(e); :}
                    | EXPR:e1 PLUS:op CALC_MUL:e2                                           {: RESULT = Component.expr(op, e1, e2); :}
                    | EXPR:e1 MINUS:op CALC_MUL:e2                                          {: RESULT = Component.expr(op, e1, e2); :}
                    ;

CALC_MUL        ::= VAL:e                                                                   {: RESULT = e; :}
                    | CALC_MUL:e1 MUL:op VAL:e2                                             {: RESULT = Component.expr(op, e1, e2); :}
                    | CALC_MUL:e1 DIV:op VAL:e2                                             {: RESULT = Component.expr(op, e1, e2); :}
                    | CALC_MUL:e1 MOD:op VAL:e2                                             {: RESULT = Component.expr(op, e1, e2); :}
                    ;

// variable assignments
ASSIGN 	        ::= VAR:v ASSIGN_OP:op EXPR:e STOP                                          {: RESULT = Component.assgn(op, v, e); :}
                    | VAR:v INC:op STOP                                                     {: RESULT = Component.assgn(op, v); :}
                    | VAR:v DEC:op STOP                                                     {: RESULT = Component.assgn(op, v); :}
                    ;

ASSIGN_OP       ::= EQUAL:op                                                                {: RESULT = op; :}
                    | PLUSEQ:op                                                             {: RESULT = op; :}
                    | MINEQ:op                                                              {: RESULT = op; :}
                    | DIVEQ:op                                                              {: RESULT = op; :}
                    | MULEQ:op                                                              {: RESULT = op; :}
                    | MODEQ:op                                                              {: RESULT = op; :}
                    ;

// variable declaration
DECL 	        ::= TYPE:t VAR:e1 STOP                                                      {: RESULT = Component.decl(t, e1); :}
                    | TYPE:t VAR:e1 EQUAL EXPR:e2 STOP                                      {: RESULT = Component.decl(t, e1, e2); :}
                    ;

// base components
TYPE            ::= STRTYPE:t                                                               {: RESULT = t; :}
                    | NUMTYPE:t                                                             {: RESULT = t; :}
                    | BOOLTYPE:t                                                            {: RESULT = t; :}
                    ;

VAL             ::= VAR:str                                                                 {: RESULT = str; :}
                    | STR:str                                                               {: RESULT = str; :}
                    | BOOL:b                                                                {: RESULT = b; :}
                    | NUM:n                                                                 {: RESULT = n; :}
                    | FUNCALL:f                                                             {: RESULT = f; :}
                    | COND:c                                                                {: RESULT = c; :}
                    | EXCL:op VAL:e                                                         {: RESULT = Component.cond(op, e); :}
                    | MINUS:op VAL:e                                                        {: RESULT = Component.expr(op, e); :}
                    ;
