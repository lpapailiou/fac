



FUNDEF 	    ::=       DEF TYPEDEF BL REP_PARAMDEF BR CBL REP_STMT RET CBR                     {: System.out.println("FUNDEF"); :}
                    ;
PARAM 	        ::= TYPE                                                        {: System.out.println("PARAM"); :}
                    | TYPE COMMA PARAM                                    {: System.out.println("PARAM"); :}
                    ;
FUNCALL 	    ::= VAR BL PARAM BR                    {: System.out.println("FUNCALL"); :}
                    ;

// this function should print the content of the variable to the console when called
PRINTCALL 	    ::= PRINT BL TYPE BR STOP                    {: System.out.println("PRINTCALL"); :}
                    ;

// structures (variable definitions and assignments, if-else, while, ...)







STMT 	    ::= STOP                                                        {: RESULT = Stmt.empty(); :}
                    | CBL stmtlist:sl CBR                                   {: RESULT = Stmt.compound(sl); :}
                    | ASSIGN                                                {: System.out.println("STRUCT"); :}
                    | DECL                                                {: System.out.println("STRUCT"); :}
                    | IF COND:c CBL STMT:s CBR                              {: Stmt.ifthen(c, s); :}
                    | IF COND:c CBL STMT:s1 CBR ELSE CBL STMT:s2 CBR        {: Stmt.ifthenelse(c, s1, s2); :}
                    | WHILE COND:c CBL STMT:s CBR                           {: Stmt.whileloop(c, s); :}
                    | PRINTCALL:p                                           {: System.out.println(p); :}
                    ;

// arithmetic expressions. brackets are optional, mul/div has precedence over plus/minus
EXPR 	        ::= CALC_MUL:e                                              {: RESULT = e; :}
                    | EXPR:e1 PLUS CALC_MUL:e2                              {: RESULT = e1 + e2; :}
                    | EXPR:e1 MINUS CALC_MUL:e2                             {: RESULT = e1 - e2; :}
                    ;
CALC_MUL      ::= NUM_VAL:e                                                 {: RESULT = e; :}
                    | BL CALC_MUL:e BR                                      {: RESULT = e; :}
                    | CALC_MUL:e1 MUL NUM_VAL:e2                            {: RESULT = e1 * e2; :}
                    | CALC_MUL:e1 DIV NUM_VAL:e2                            {: RESULT = e1 / e2; :}
                    ;

// boolean conditions. brackets are mandatory, no precedence order needed
COND 	        ::= BL VAR:e BR                                           {: RESULT = e; :}
                    | BL BOOL_VAL:e1 AND BOOL_VAL:e2 BR                        {: RESULT = e1 && e2; :}
                    | BL BOOL_VAL:e1 OR BOOL_VAL:e2 BR                         {: RESULT = e1 || e2; :}
                    | BL BOOL_VAL:e1 EQ BOOL_VAL:e2 BR                         {: RESULT = e1 == e2; :}
                    | BL BOOL_VAL:e1 NEQ BOOL_VAL:e2 BR                        {: RESULT = e1 != e2; :}

                    | BL NUM_VAL:e1 EQ NUM_VAL:e2 BR                           {: RESULT = e1 == e2; :}
                    | BL NUM_VAL:e1 NEQ NUM_VAL:e2 BR                          {: RESULT = e1 != e2; :}
                    | BL NUM_VAL:e1 GREATER NUM_VAL:e2 BR                      {: RESULT = e1 > e2; :}
                    | BL NUM_VAL:e1 GREQ NUM_VAL:e2 BR                         {: RESULT = e1 >= e2; :}
                    | BL NUM_VAL:e1 LEQ NUM_VAL:e2 BR                          {: RESULT = e1 <= e2; :}
                    | BL NUM_VAL:e1 LESS NUM_VAL:e2 BR                         {: RESULT = e1 < e2; :}

                    | BL STR_VAL:e1 EQ STR_VAL:e2 BR                           {: RESULT = e1 == e2; :}
                    | BL STR_VAL:e1 NEQ STR_VAL:e2 BR                          {: RESULT = e1 != e2; :}
                    ;







// return
RET 	        ::= RETURN NUM_VAL:r STOP                                       {: RESULT = r; :}
                    | RETURN BOOL_VAL:r STOP                                    {: RESULT = r; :}
                    | RETURN STR_VAL:r STOP                                     {: RESULT = r; :}
                    ;









